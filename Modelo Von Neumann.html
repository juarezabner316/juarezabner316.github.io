<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Modelo de Von Neumann - Interactivo</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leader-line/1.0.7/leader-line.min.js"></script>
  <style>
    * {
      margin: 0; padding: 0; box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: #f4f6f8;
      padding: 20px;
      min-height: 100vh;

    /* Opcional: solo si quieres centrar la .container */
    display: flex;
    justify-content: center;
    /* align-items: center;  <- puedes quitarlo si no quieres centrar vertical */
    }

    .container {
      max-width: 1200px;
      margin: auto;
      background: #fff;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      overflow: hidden;
      position: relative;

    }
.modal-content img {
  display: block;
  margin: 20px auto;
  border-radius: 15px;
  width: 100%;         /* ocupa todo el ancho del modal */
  max-width: 800px;    /* no m√°s de 800px */
  height: auto;        /* mantiene proporci√≥n */
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
    .header {
      background: #EDED8E;
      color: black;
      padding: 30px;
      text-align: center;
    }

    .header h1 {
      font-size: 2.5rem;
    }

    .header p {
      font-size: 1.1rem;
      margin-top: 10px;
    }

    .diagram-container {
      padding: 50px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto auto;
      gap: 40px;
      position: relative;
      z-index: 1;
    }

    .component {
      background-color: #ecf0f1;
      border-radius: 15px;
      padding: 25px;
      cursor: pointer;
      transition: transform 0.3s ease;
      box-shadow: 0 5px 15px rgba(0,0,0,0.05);
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .component:hover {
      transform: scale(1.03);
    }

    .component h3, .component h4 {
      font-size: 1.4rem;
      margin-bottom: 10px;
    }

    .component p {
      font-size: 1rem;
      color: #333;
    }

    .component span.author {
      display: block;
      margin-top: 10px;
      font-size: 0.85rem;
      color: #888;
    }

    .cpu-container {
      grid-column: 1;
      grid-row: 1;
      background-color: #68A2D2;
    }

    .cpu-subcomponents {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .alu, .control-unit {
      flex: 1 1 45%;
      padding: 15px;
      border-radius: 10px;
    }

    .alu {
      background-color: #EFE4C6;
    }

    .control-unit {
      background-color: #B3E2EA;
    }

    .memory {
      grid-column: 2;
      grid-row: 1;
      background-color: #B7EBDE;
    }

    .io {
      grid-column: 3;
      grid-row: 1;
      background-color: #C9CDF2;
    }

    .bus {
      grid-column: 1 / 4;
      grid-row: 2;
      background-color: #F3E1D3;
    }

    .legend {
      text-align: center;
      padding: 15px;
      background-color: #dfe6e9;
      font-size: 0.9rem;
      color: #2d3436;
    }

    @media (max-width: 768px) {
      .diagram-container {
        grid-template-columns: 1fr;
        padding: 30px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üñ•Ô∏è Modelo de Von Neumann</h1>
      <p>Sistemas Operativos Grupo 2</p>
    </div>

    <div class="diagram-container">
      <div class="component cpu-container" id="cpu" data-component="cpu">
        <h3>üß† CPU (Procesador)</h3>
        <p>Unidad Central de Procesamiento</p>
        <div class="cpu-subcomponents">
          <div class="alu component" data-component="alu">
            <h4>üî¢ ALU</h4>
            <p>Unidad Aritm√©tica y L√≥gica</p>
            <span class="author">Jose Torres</span>
          </div>
          <div class="control-unit component" data-component="control">
            <h4>‚öôÔ∏è UC</h4>
            <p>Unidad de Control</p>
            <span class="author">Roger Herrera</span>
          </div>
        </div>
      </div>

      <div class="component memory" id="memory" data-component="memory">
        <h3>üíæ Memoria Principal</h3>
        <p>Almacena programas y datos</p>
        <span class="author">Natali Montenegro</span>
      </div>

      <div class="component io" id="io" data-component="io">
        <h3>üîå Entrada y Salida</h3>
        <p>Interacci√≥n con el exterior</p>
        <span class="author">Abner Juarez</span>
      </div>

      <div class="component bus" id="bus" data-component="bus">
        <h3>üõ§Ô∏è BUS del Sistema</h3>
        <p>Comunicaci√≥n entre componentes</p>
        <span class="author">Abner Juarez</span>
      </div>
    </div>

    <div class="legend">
      üí° Haz clic en cualquier componente para ver informaci√≥n detallada
    </div>
  </div>

  

 <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: #f0f2f5;
      padding: 30px;
    }

    h1 {
      text-align: center;
      margin-bottom: 20px;
    }

    .von-neumann {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto auto auto;
      gap: 30px;
      max-width: 1200px;
      margin: auto;
      position: relative;
    }

    .box {
      background-color: #ecf0f1;
      border: 2px dashed #aaa;
      padding: 15px;
      border-radius: 12px;
      text-align: center;
      position: relative;
    }

    .cpu {
      grid-column: 1 / 2;
      grid-row: 1 / 2;
    }

    .alu, .uc {
      background-color: #d0ebff;
      border: 2px dashed #5b8bd0;
      margin-top: 10px;
    }

    .memory {
      grid-column: 2 / 3;
      grid-row: 1 / 2;
      background-color: #b7ebde;
    }

    .io {
      grid-column: 3 / 4;
      grid-row: 1 / 2;
    }

    .io .box {
      background-color: #c9cdf2;
      margin-bottom: 10px;
    }

    .bus {
      grid-column: 1 / 4;
      grid-row: 2 / 3;
      background-color: #ffe0b3;
      font-weight: bold;
    }

    .label {
      font-size: 0.85rem;
      color: #444;
      margin-top: 4px;
    }

    .author {
      font-size: 0.75rem;
      color: #666;
      margin-top: 5px;
    }

    /* Arrows (simplified using CSS only) */
    .arrow {
      position: absolute;
      width: 100px;
      height: 2px;
      background: repeating-linear-gradient(to right, black 0 5px, transparent 5px 10px);
      z-index: 10;
    }

    /* Flechas */
    .arrow1 {
      top: 120px;
      left: 330px;
      transform: rotate(0deg);
    }

    .arrow2 {
      top: 120px;
      left: 660px;
      transform: rotate(0deg);
    }

    .arrow3 {
      width: 2px;
      height: 80px;
      background: repeating-linear-gradient(to bottom, black 0 5px, transparent 5px 10px);
      top: 200px;
      left: 600px;
    }

    .arrow4 {
      width: 2px;
      height: 80px;
      background: repeating-linear-gradient(to bottom, black 0 5px, transparent 5px 10px);
      top: 200px;
      left: 250px;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .von-neumann {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
      }

      .arrow {
        display: none;
      }
    }
  </style>
</head>
<body>
   ¬∫

    <!-- MODAL -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">√ó</button>
            <div id="modalBody">
                <h2>Selecciona un componente</h2>
                <p>Haz clic en cualquier parte del diagrama para conocer m√°s detalles sobre cada componente del modelo de Von Neumann.</p>
            </div>
        </div>
    </div>

    <style>
        .modal-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            animation: fadeIn 0.3s ease-in-out;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: #ffffff;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 30px;
            border-radius: 15px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease-out;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 1.2rem;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
        }

        #modalBody h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        #modalBody p, #modalBody ul {
            font-size: 1rem;
            line-height: 1.7;
            color: #444;
        }

        #modalBody ul {
            margin-left: 20px;
        }

        @keyframes fadeIn {
            from { opacity: 0; } to { opacity: 1; }
        }

        @keyframes slideUp {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>

    <script>
        const components = document.querySelectorAll('.component');
        const modalOverlay = document.getElementById('modalOverlay');
        const modalBody = document.getElementById('modalBody');

        const contentMap = {
            cpu: {
                title: 'üß† CPU - Unidad Central de Procesamiento',
                content: `
                    <p>La CPU es el "cerebro" del sistema. Est√° compuesta por la ALU (Unidad Aritm√©tica y L√≥gica) y la UC (Unidad de Control).</p>
                    <ul>
                        <li>Ejecuta instrucciones</li>
                        <li>Coordina operaciones internas</li>
                        <li>Gestiona el flujo de datos</li>
                    </ul>
<br>
<br>
                    <section>
  <h1>üìå Estados de un Proceso (Modelo Von Neumann)</h1>
 
 <center> <span class="author">Abner Juarez</span></center>
  <br>
<img src="iconos/ciclodeviida.jpeg" alt="Ciclo de Vida" 
     ">



<br>

  <p>
    En un sistema operativo, los procesos cambian de estado seg√∫n usen la <strong>CPU</strong>, 
    esperen <strong>E/S</strong> o sean enviados a <strong>swap</strong> por falta de memoria.
  </p>

  <h2>üîπ Estados en RAM (Planificaci√≥n a corto plazo)</h2>
  <ul>
    <li><strong>Ejecuci√≥n (E):</strong> el proceso usa la CPU.</li>
    <li><strong>Listo (P):</strong> est√° en RAM, esperando CPU.</li>
    <li><strong>Bloqueado (B):</strong> espera una operaci√≥n de E/S.</li>
  </ul>

  <h2>üîπ Estados en Disco/Swap (Planificaci√≥n a mediano plazo)</h2>
  <ul>
    <li><strong>Listo Suspendido (PS):</strong> estaba listo, pero fue enviado a disco.</li>
    <li><strong>Bloqueado Suspendido (BS):</strong> estaba bloqueado y fue expulsado a disco.</li>
  </ul>

  <h2>üîπ Transiciones principales</h2>
  <ul>
    <li><strong>P ‚Üí E:</strong> pasa a ejecuci√≥n.</li>
    <li><strong>E ‚Üí P:</strong> fin de turno (<em>time slice</em>).</li>
    <li><strong>E ‚Üí B:</strong> solicita E/S.</li>
    <li><strong>B ‚Üí P:</strong> termina la E/S.</li>
    <li><strong>P/B ‚Üí PS/BS:</strong> expulsi√≥n a disco (swap-out).</li>
    <li><strong>PS/BS ‚Üí P/B:</strong> regreso a RAM (swap-in).</li>
    <li><strong>E ‚Üí Fin:</strong> el proceso termina.</li>
  </ul>

  <p>
    Este resumen refleja c√≥mo el sistema operativo gestiona procesos en el 
    <strong>modelo Von Neumann</strong>: 
    <em>Planificaci√≥n a largo plazo</em> (entrada de procesos), 
    <em>a mediano plazo</em> (swap) y 
    <em>a corto plazo</em> (CPU).
  </p>
</section>
                `
            },
            alu: {
                 title: 'üî¢ ALU - Unidad Aritm√©tica y L√≥gica',
    content: `
        <p>La ALU (Unidad Aritm√©tico-L√≥gica) es uno de los componentes m√°s fundamentales de la CPU. Su funci√≥n es ejecutar operaciones matem√°ticas y l√≥gicas directamente sobre datos binarios, y desempe√±a un papel central en la arquitectura de Von Neumann.</p>

        <p><strong>Funciones principales:</strong></p>
        <ul>
            <li>Realiza operaciones aritm√©ticas b√°sicas: suma, resta, multiplicaci√≥n y divisi√≥n.</li>
            <li>Ejecuta operaciones l√≥gicas: AND, OR, NOT, XOR, comparaciones (mayor, menor, igual), desplazamientos y rotaciones.</li>
            <li>Genera banderas o "flags" en registros de estado que indican condiciones como cero, acarreo, negativo o desbordamiento.</li>
        </ul>

        <p><strong>Componentes internos clave:</strong></p>
        <ul>
            <li><strong>Registros de entrada:</strong> almacenan los operandos a utilizar.</li>
            <li><strong>Registro acumulador:</strong> guarda resultados intermedios o finales.</li>
            <li><strong>Multiplexores:</strong> seleccionan qu√© operaci√≥n enviar como salida.</li>
            <li><strong>Circuitos operacionales:</strong> ejecutan los c√°lculos y evaluaciones.</li>
            <li><strong>Registros de estado:</strong> notifican el resultado de las operaciones a la Unidad de Control.</li>
        </ul>

        <p><strong>Interacci√≥n con la Unidad de Control:</strong> la ALU no decide qu√© operaci√≥n ejecutar por s√≠ sola. Depende de se√±ales de control externas que le indican qu√© funci√≥n realizar. Tambi√©n proporciona retroalimentaci√≥n a la Unidad de Control para permitir instrucciones condicionales como saltos, bucles, etc.</p>

        <p><strong>Relaci√≥n con la Arquitectura de Von Neumann:</strong> la ALU forma parte esencial del modelo de programa almacenado propuesto por John von Neumann. Procesa tanto datos como instrucciones que se encuentran en la misma memoria, permitiendo flexibilidad y programaci√≥n din√°mica.</p>

        <p><strong>Dise√±o e implementaci√≥n:</strong></p>
        <ul>
            <li>Construida mediante circuitos combinacionales, sumadores paralelos y compuertas l√≥gicas.</li>
            <li>Operaciones seleccionadas por se√±ales S0, S1 y S2.</li>
            <li>ALUs modernas usan lenguajes como VHDL y tecnolog√≠as como transistores neuMOS para mejorar eficiencia y reducir tama√±o.</li>
        </ul>
    `

            },
            control: {
    title: '‚öô UC - Unidad de Control',
    content: `
        <p>Caracter√≠sticas especiales:</p>
        <ul>
            <li>La unidad de control es el componente principal del procesador.</li>
            <li>Funciona como un circuito en serie para completar el proceso de aprendizaje.</li>
            <li>Su funci√≥n principal es activar y generar se√±ales el√©ctricas internas para controlar los datos y las funciones del dispositivo.</li>
            <li>Recuperar las instrucciones almacenadas en la memoria y ejecutar cada operaci√≥n directamente.</li>
        </ul>

        <p><strong>C√≥mo:</strong></p>
        <ol>
            <li>Obtener la siguiente instrucci√≥n a ejecutar desde la memoria seg√∫n la direcci√≥n almacenada en la interfaz de programaci√≥n (IP).</li>
            <li>Modificar la instrucci√≥n para describir la operaci√≥n a realizar (suma, resta, carga, salto, etc.).</li>
            <li>Ejecutar la instrucci√≥n utilizando las se√±ales adecuadas para controlar la ALU, los registros y la memoria y garantizar su correcto funcionamiento.</li>
            <li>Guardar el resultado en una lista o en la memoria correspondiente.</li>
            <li>Actualizar la hoja de c√°lculo para mostrar la siguiente lecci√≥n, secuencialmente o con un salto condicional.</li>
        </ol>

        <p><strong>Buscar:</strong></p>
        <ul>
            <li>Ajusta la memoria para leer instrucciones y mensajes.</li>
            <li>Controla la unidad aritm√©tico-l√≥gica (ALU) para realizar operaciones aritm√©ticas y l√≥gicas.</li>
            <li>Controla el movimiento de datos entre los registros internos y la memoria principal.</li>
            <li>El flujo de instrucciones se controla mediante el b√∫fer de programa y las interrupciones de instrucciones.</li>
            <li>Monitorea las se√±ales internas que garantizan la correcta finalizaci√≥n de cada etapa del ciclo de entrenamiento.</li>
        </ul>

        <p>En aplicaciones en desarrollo, tambi√©n se consideran las interrupciones basadas en eventos y los mecanismos de recuperaci√≥n externos.</p>

        <p><strong>Temas relacionados:</strong></p>
        <ul>
            <li>Parte del dise√±o de von Neumann, en el que los datos y las instrucciones se almacenan en una memoria compartida.</li>
            <li>Se utiliza el ciclo de control, una funci√≥n importante en el desarrollo de software.</li>
            <li>Se utilizan se√±ales el√©ctricas para regular la interacci√≥n entre la ALU, los registros, la memoria y otros componentes.</li>
            <li>Garantiza que las instrucciones se ejecuten con rapidez y precisi√≥n en una m√°quina virtual.</li>
        </ul>

        <p><strong>Importancia:</strong></p>
        <ul>
            <li>Es el "director de orquesta" que garantiza el correcto funcionamiento de la CPU y la correcta ejecuci√≥n de los programas.</li>
            <li>Su dise√±o y funcionamiento mantienen la estructura secuencial cl√°sica que ha permanecido vigente en la mayor√≠a de los computadores modernos.</li>
        </ul>
<section>
  <h1>üìå Algoritmos</h1>
   <center> <span class="author">Roger Herrera</span></center>
    <br>
  <p>
    Los algoritmos en sistemas operativos se dividen en tres grandes grupos: 
    planificaci√≥n, soluciones de sincronizaci√≥n y desbloqueo.
  </p>

  <h2>De planificaci√≥n:</h2>
  <ul>
    <li><strong>Round Robin (RR)</strong> ‚Üí La CPU se reparte en turnos iguales. Cada proceso recibe un tiempo fijo.</li>
    <li><strong>PEPS (cola)</strong> ‚Üí Atiende procesos en el orden en que llegaron (primero en entrar, primero en salir).</li>
    <li><strong>UEPS (pila)</strong> ‚Üí Atiende primero al proceso m√°s reciente (√∫ltimo en entrar, primero en salir).</li>
    <li><strong>Aleatorio</strong> ‚Üí El proceso siguiente se elige al azar. No es predecible, pero sirve en pruebas o simulaciones.</li>
  </ul>

  <h2>De soluciones:</h2>
  <ul>
    <li><strong>Cena de los Fil√≥sofos</strong> ‚Üí Varios procesos comparten recursos; si no se coordinan, hay riesgo de bloqueo (<em>deadlock</em>).</li>
    <li><strong>Barbero</strong> ‚Üí Modelo de atenci√≥n con clientes que esperan como en una cola.</li>
    <li><strong>Productor-Consumidor</strong> ‚Üí Productores generan datos y consumidores los usan; requieren coordinaci√≥n con un buffer compartido.</li>
    <li><strong>Lectores-Escritores</strong> ‚Üí Los lectores pueden entrar juntos, pero los escritores necesitan exclusi√≥n total.</li>
  </ul>

  <h2>De desbloqueo:</h2>
  <ul>
    <li><strong>Banquero</strong> ‚Üí M√©todo para evitar deadlock: solo concede recursos si despu√©s de hacerlo el sistema puede seguir funcionando de manera segura.</li>
  </ul>
</section>

<br>
<br>
        <h1>Comunicaci√≥n entre Procesos (IPC)</h1>
           <center> <span class="author">Roger Herrera</span></center>
    <br>

<h2>1. Concepto</h2>
<p>
La <strong>comunicaci√≥n entre procesos (IPC)</strong> es el conjunto de mecanismos 
que permiten que varios procesos intercambien datos, cooperen y se sincronicen 
para alcanzar un objetivo com√∫n. Es necesaria porque los procesos pueden ser 
independientes o cooperantes y a menudo comparten recursos.
</p>

<h2>2. Tipos de procesos</h2>
<ul>
  <li><strong>Independientes:</strong> se ejecutan sin necesidad de otros procesos.</li>
  <li><strong>Cooperantes:</strong> trabajan en conjunto, comparten informaci√≥n y recursos.</li>
</ul>

<h2>3. Problemas cl√°sicos de sincronizaci√≥n</h2>
<ul>
  <li><strong>Secci√≥n cr√≠tica:</strong> parte del c√≥digo donde se accede a recursos compartidos, 
      debe garantizarse exclusi√≥n mutua.</li>
  <li><strong>Productor‚ÄìConsumidor:</strong> un proceso genera datos y otro los consume; 
      requiere sincronizaci√≥n con buffers.</li>
  <li><strong>Lectores‚ÄìEscritores:</strong> varios lectores pueden acceder en paralelo, 
      pero los escritores requieren acceso exclusivo.</li>
  <li><strong>Cliente‚ÄìServidor:</strong> un proceso solicita un servicio (cliente) y otro lo atiende (servidor).</li>
</ul>

<h2>4. Mecanismos de comunicaci√≥n</h2>
<ul>
  <li><strong>Archivos:</strong> permiten comunicar procesos, aunque son lentos.</li>
  <li><strong>Tuber√≠as (pipes, FIFOs):</strong> canales unidireccionales o bidireccionales 
      que permiten enviar y recibir datos.</li>
  <li><strong>Memoria compartida:</strong> espacio com√∫n de memoria para que los procesos intercambien informaci√≥n.</li>
  <li><strong>Paso de mensajes:</strong> env√≠o y recepci√≥n de datos a trav√©s del sistema operativo.</li>
</ul>

<h2>5. Mecanismos de sincronizaci√≥n</h2>
<ul>
  <li><strong>Sem√°foros:</strong> variables enteras que controlan acceso mediante operaciones <code>wait</code> y <code>signal</code>.</li>
  <li><strong>Mutex:</strong> ‚Äúcandado‚Äù que asegura que solo un proceso/hilo acceda al recurso a la vez.</li>
  <li><strong>Variables condicionales:</strong> permiten suspender un proceso hasta que se cumpla una condici√≥n.</li>
</ul>

<h2>6. Interbloqueos (Deadlocks)</h2>
<p>
Un interbloqueo ocurre cuando varios procesos esperan indefinidamente recursos 
que otros poseen. Para que ocurra deben cumplirse simult√°neamente:
<strong>exclusi√≥n mutua</strong>, <strong>retenci√≥n y espera</strong>, 
<strong>no expropiaci√≥n</strong> y <strong>espera circular</strong>.
</p>
<p><strong>Estrategias:</strong> detecci√≥n y recuperaci√≥n, prevenci√≥n, predicci√≥n de estados seguros o ignorar el problema.</p>
    `
},
           memory: {
    title: 'üíæ Memoria Principal',
    content: `
       <p>üíæ <strong>¬øQu√© es la Memoria Principal?</strong><br> La RAM es una memoria temporal que guarda los datos y programas que la computadora est√° usando en el momento. Al apagarse, se borra todo su contenido.</p>
<p>üìç <strong>¬øQu√© hace en el modelo Von Neumann?</strong><br> Guarda instrucciones y datos que la CPU necesita. Sin ella, no se pueden ejecutar programas ni funcionar el sistema operativo.</p>
<p>üß© <strong>Tipos de RAM m√°s usados:</strong></p> <ul> <li><strong>üí∏ DRAM:</strong> Com√∫n, econ√≥mica y usada como memoria principal.</li> <li><strong>‚ö° SRAM:</strong> R√°pida y estable, usada en memoria cach√©.</li> </ul>
<p>üîç <strong>Caracter√≠sticas clave:</strong></p> <ul> <li>üìå <strong>Acceso aleatorio:</strong> Se puede acceder a cualquier dato directamente.</li> <li>üöÄ <strong>Alta velocidad:</strong> Mucho m√°s r√°pida que un disco duro.</li> <li>‚ö† <strong>Vol√°til:</strong> Se borra al apagar la computadora.</li> </ul>
<p>üèó <strong>Jerarqu√≠a de memoria:</strong><br> La RAM es parte de una jerarqu√≠a de memoria que organiza los niveles seg√∫n su velocidad y cercan√≠a a la CPU. Las m√°s r√°pidas (como registros y cach√©) est√°n arriba, y las m√°s lentas (como el disco duro), abajo. La RAM guarda datos que se usar√°n pronto y permite que el sistema funcione con rapidez.</p>
<p>üß† <strong>Importancia hoy en d√≠a:</strong><br> La RAM permite que programas como videojuegos, editores de video o sistemas de IA funcionen sin trabarse. Cuanta m√°s RAM y m√°s r√°pida, mejor rendimiento multitarea.</p>


<br>
<br>

<section>
  <h1>üìå Gesti√≥n de memoria</h1>
     <center> <span class="author">Natali Montenegro</span></center>
    <br>

  <img src="iconos/jerarquiamemoria.jpeg" alt="Jerarquia de Memoria" 
     ">
  <p>
    Es el conjunto de funciones y t√©cnicas que utiliza el sistema operativo para administrar la 
    <strong>memoria principal</strong> en el modelo de Von Neumann.
  </p>
  <p>
    Su prop√≥sito es garantizar <em>aislamiento</em>, <em>seguridad</em> y <em>eficiencia</em>, de forma que cada 
    proceso crea tener la m√°quina para s√≠ mismo, mientras comparte recursos con otros.
  </p>
  <p>
    Incluye:
  </p>
  <ul>
    <li><strong>Espacios l√≥gicos independientes</strong> ‚Üí cada proceso tiene su propio espacio de direcciones.</li>
    <li><strong>Reubicaci√≥n y protecci√≥n</strong> ‚Üí traducci√≥n de direcciones l√≥gicas a f√≠sicas mediante la MMU y validaciones de acceso.</li>
    <li><strong>Compartici√≥n de memoria</strong> ‚Üí zonas comunes (ej. bibliotecas) que varios procesos pueden usar simult√°neamente.</li>
    <li><strong>Soporte de regiones</strong> ‚Üí el mapa de un proceso incluye c√≥digo, datos, pila, heap y archivos proyectados, cada uno con permisos espec√≠ficos.</li>
    <li><strong>Maximizar multiprogramaci√≥n</strong> ‚Üí reducir fragmentaci√≥n y administrar asignaci√≥n para m√°s procesos activos.</li>
    <li><strong>Memoria virtual</strong> ‚Üí combinaci√≥n de RAM y disco que simula m√°s memoria (paginaci√≥n, segmentaci√≥n, reemplazo de p√°ginas).</li>
  </ul>
  <p>
    <em>T√©cnicas destacadas:</em> paginaci√≥n, segmentaci√≥n y pol√≠ticas de reemplazo (FIFO, LRU, Reloj).
  </p>
</section>

<br>
<br>
<section>
  <h2>üìå BCP (Bloque de Control de Proceso)</h2>
       <center> <span class="author">Natali Montenegro</span></center>
    <br>
  <p>
    Es una estructura que guarda toda la informaci√≥n necesaria para administrar un proceso.
  </p>
  <p>
    Incluye:
  </p>
  <ul>
    <li><strong>Identificadores</strong> ‚Üí PID (proceso) y UID (usuario due√±o).</li>
    <li><strong>Archivos abiertos</strong> ‚Üí lista de recursos en uso.</li>
    <li><strong>Memoria asignada</strong> ‚Üí p√°ginas, marcos y regiones (RIED).</li>
    <li><strong>Temporizadores</strong> ‚Üí controlan tiempo de CPU y vencimiento.</li>
    <li><strong>Se√±ales</strong> ‚Üí permiten que procesos se comuniquen entre s√≠.</li>
    <li><strong>Mecanismos de sincronizaci√≥n</strong> ‚Üí mutex y sem√°foros para proteger acceso a memoria compartida.</li>
    <li><strong>Puertos</strong> ‚Üí canales de comunicaci√≥n, controlados por firewall o herramientas como <em>nmap</em>.</li>
  </ul>
  <p>
    El BCP es clave en el <strong>cambio de contexto</strong>: el sistema guarda y recupera esta informaci√≥n 
    para detener y reanudar procesos.
  </p>
</section>
<br>
<br>

<section>
  <h2>üìå Core Image</h2>
     <center> <span class="author">Jose Torres</span></center>
    <br>
  <p>
    Es la <strong>imagen binaria</strong> que se genera al compilar un programa y que se transfiere del 
    <strong>disco duro</strong> a la <strong>RAM</strong> en mil√©simas de segundo al momento de ejecutarlo.
  </p>
  <p>
    Contiene:
  </p>
  <ul>
    <li><strong>C√≥digo objeto</strong> ‚Üí instrucciones listas para el procesador (PC, IR).</li>
    <li><strong>Datos</strong> ‚Üí variables, constantes y estructuras de informaci√≥n.</li>
    <li><strong>Estructuras</strong> ‚Üí pilas, colas, grafos, etc.</li>
  </ul>
  <p>
    <em>Es el programa listo para ejecutarse en memoria.</em>
  </p>
</section>



<br>
<br>
<section>
  <h1>üìå Traducci√≥n de memoria</h1>
       <center> <span class="author">Jose Torres</span></center>
    <br>

  <img src="iconos/mmu.jpeg" alt="Traducci√≥n de Memoria" 
     ">
  
  <h2>üîπ De 1 nivel</h2>
  <p>
    Se usa una sola tabla que funciona como un <strong>‚Äúdiccionario‚Äù</strong>, la cual convierte 
    direcciones virtuales en direcciones f√≠sicas de la RAM.
  </p>
  <p><strong>Componentes:</strong></p>
  <ul>
    <li><strong>UC</strong> ‚Üí solicita traducci√≥n y genera la direcci√≥n virtual.</li>
    <li><strong>MMU (Unidad de Gesti√≥n de Memoria)</strong> ‚Üí consulta la tabla de p√°ginas.</li>
    <li><strong>Tabla de p√°ginas</strong> ‚Üí contiene la relaci√≥n entre p√°ginas virtuales y marcos f√≠sicos.</li>
    <li><strong>RAM</strong> ‚Üí almacena los marcos de memoria donde realmente est√°n los datos.</li>
  </ul>
  <p><strong>Funcionamiento:</strong></p>
  <ul>
    <li><strong>1.</strong> ‚Üí El programa pide una direcci√≥n (virtual).</li>
    <li><strong>2.</strong> ‚Üí La MMU busca esa direcci√≥n en la tabla de p√°ginas.</li>
    <li><strong>3.</strong> ‚Üí La tabla indica en qu√© marco de la RAM est√° la p√°gina.</li>
    <li><strong>4.</strong> ‚Üí La direcci√≥n virtual se traduce en direcci√≥n f√≠sica.</li>
    <li><strong>5.</strong> ‚Üí Se accede a esa posici√≥n en memoria.</li>
  </ul>
  <p>
    <strong>Nota:</strong>  
    Si la p√°gina solicitada no est√° en RAM y no hay espacio, el sistema realiza 
    <em>swap</em> ‚Üí se libera espacio moviendo p√°ginas a disco y se carga la nueva p√°gina en memoria.
  </p>

  <h2>üîπ De 2 niveles</h2>
  <p>
    Se usan <strong>dos tablas en jerarqu√≠a</strong>, lo que permite reducir el tama√±o total de la tabla 
    de p√°ginas y aprovechar mejor la memoria.
  </p>
  <p><strong>Componentes:</strong></p>
  <ul>
    <li><strong>UC</strong> ‚Üí genera la direcci√≥n virtual dividida en: √≠ndice de tabla 1, √≠ndice de tabla 2 y desplazamiento.</li>
    <li><strong>MMU</strong> ‚Üí consulta la tabla de primer nivel y luego la de segundo nivel.</li>
    <li><strong>Tabla de primer nivel</strong> ‚Üí indica qu√© tabla secundaria usar.</li>
    <li><strong>Tabla de segundo nivel</strong> ‚Üí contiene la relaci√≥n entre p√°ginas virtuales y marcos f√≠sicos.</li>
    <li><strong>RAM</strong> ‚Üí almacena los marcos de memoria donde est√°n los datos.</li>
  </ul>
  <p><strong>Funcionamiento:</strong></p>
  <ul>
    <li><strong>1.</strong> ‚Üí El programa pide una direcci√≥n (virtual).</li>
    <li><strong>2.</strong> ‚Üí La MMU consulta la <em>tabla de primer nivel</em>.</li>
    <li><strong>3.</strong> ‚Üí Esa tabla indica cu√°l <em>tabla de segundo nivel</em> usar.</li>
    <li><strong>4.</strong> ‚Üí En la tabla de segundo nivel se obtiene el marco de la RAM.</li>
    <li><strong>5.</strong> ‚Üí Se une el marco con el desplazamiento para formar la direcci√≥n f√≠sica.</li>
    <li><strong>6.</strong> ‚Üí Se accede a esa posici√≥n en memoria.</li>
  </ul>
  <p>
    <strong>Nota:</strong>  
    Si la p√°gina solicitada no est√° en RAM y no hay espacio disponible, el sistema hace 
    <em>swap</em> con el disco: mueve p√°ginas viejas a almacenamiento secundario y trae la nueva.
  </p>
</section>
    `
},
          bus: {
    title: 'üõ§Ô∏è BUS del Siste    ma (Abner Juarez)',
    content: `
        <p>El bus de datos es el canal de comunicaci√≥n entre las tres partes principales de un modelo de Von Neumann: el procesador, la memoria principal y los m√≥dulos de entrada/salida (E/S). Proporciona un ancho de banda de datos entre ellos permitiendo que la informaci√≥n fluya entre los componentes.</p>

<h4>√Årea del bus:</h4>
<ul>
  <li>
    <strong>Bus de datos:</strong> Se utiliza para procesar o almacenar datos, como instrucciones o informaci√≥n de archivo. La cantidad de bits que se pueden enviar simult√°neamente (8, 16, 32 o 64 bits) determina la longitud del bus.
  </li>
  <li>
    <strong>Bus de direcciones:</strong> Env√≠a informaci√≥n desde una fuente a una direcci√≥n de memoria o a un puerto de dispositivo E/S. La CPU tiene un l√≠mite en el n√∫mero de ranuras que puede gestionar.
  </li>
  <li>
    <strong>Bus de control:</strong> Contiene s√≠mbolos de control y estado que indican d√≥nde fluyen los datos (lectura o escritura) y los componentes asociados con las operaciones intermedias.
  </li>
</ul>

<h4>Desarrollo de autobuses:</h4>
<p>Inicialmente, los autobuses funcionaban en paralelo, lo que significaba que varios equipos transportaban suministros de datos simult√°neamente. Sin embargo, gracias a los avances tecnol√≥gicos y a la demanda de los dispositivos, existen interfaces de alta velocidad como USB (Bus Serie Universal) y PCIe (Interconexi√≥n de Componentes Perif√©ricos Express) para aumentar la velocidad y eficiencia de la transferencia de datos.</p>

    `
},
io: {
    title: 'üîå Unidad de Entrada y Salida (E/S) (Abner Juarez)',
    content: `
       <p>La unidad de Entrada/Salida (E/S) tiene la tarea de manejar la interacci√≥n entre el ordenador y el entorno exterior, esto lo hace mediante aparatos como el teclado, pantalla, discos duros y red. Estos aparatos influyen directamente en el ordenador.</p>

<h4>Elementos fundamentales:</h4>
<ul>
  <li><strong>Controlador de entrada/salida:</strong> En cada aparato, el controlador guarda los registros que el procesador puede leer o redactar para establecer comunicaci√≥n con el aparato.</li>
  <li><strong>Registro de Datos:</strong> Guarda la informaci√≥n que se env√≠a o recibe desde el dispositivo.</li>
  <li><strong>Registro de Estado:</strong> Muestra la condici√≥n actual del dispositivo, tales como ocupado, error o datos preparados para ser le√≠dos.</li>
  <li><strong>Registro de Control:</strong> Obtiene instrucciones del procesador para regular la operaci√≥n del aparato.</li>
</ul>





<h4>Acceso Directo a Memoria (DMA):</h4>
<p>Para actividades que requieren de grandes cantidades de informaci√≥n, como el intercambio de archivos desde un disco duro, el m√©todo DMA permite que un controlador transmita datos directamente entre la memoria principal y el dispositivo, evitando la intervenci√≥n continua de la CPU, liber√°ndola para otras funciones.</p>

<h4>Material Did√°ctico y Complementos para tu proyecto:</h4>
<ul>
  <li><strong>Simuladores:</strong> El Simulador de Sistemas de C√≥mputo (SIMAS) y CPUlator ayudan a visualizar el flujo de datos y el funcionamiento de interrupciones.</li>
  <li><strong>Videos educativos:</strong> Recursos como <em>"Von Neumann Architecture"</em> y <em>"Computer Buses"</em> de ITfreetraining, y <em>"I/O Systems Overview"</em> de Kevin P. Smith explican estos conceptos con ejemplos claros.</li>
</ul>

<section>
  <h1>üìå Interrupciones</h1>
       <center> <span class="author">Abner Juarez</span></center>
    <br>
  <ul>
    <li>
      <strong>Se√±al (hardware o software)</strong>  
      <p>
        Una interrupci√≥n detiene temporalmente la CPU para que atienda un evento urgente, 
        como una tecla presionada, una operaci√≥n de E/S o un error de memoria.
      </p>
    </li>
    <li>
      <strong>Rutina de servicio (ISR)</strong>  
      <p>
        Es el c√≥digo que maneja la interrupci√≥n. Realiza el trabajo m√≠nimo necesario 
        (por ejemplo, confirmar el evento) y delega el procesamiento m√°s pesado a otros procesos o hilos.
      </p>
    </li>
    <li>
      <strong>Tipos principales</strong>
      <ul>
        <li><strong>Timer</strong> ‚Üí controla el tiempo de CPU para la planificaci√≥n.</li>
        <li><strong>I/O</strong> ‚Üí generadas por dispositivos como teclado, disco o red.</li>
        <li><strong>Trap / Syscall</strong> ‚Üí creadas por software para pedir un servicio al sistema operativo.</li>
        <li><strong>Fallos de memoria</strong> ‚Üí cuando se accede a direcciones inv√°lidas o faltan p√°ginas.</li>
      </ul>
    </li>
    <li>
      <strong>Prioridad y enmascaramiento</strong>  
      <p>
        El sistema puede dar prioridad a ciertas interrupciones sobre otras y bloquear 
        (‚Äúenmascarar‚Äù) algunas se√±ales para evitar que interrumpan procesos cr√≠ticos.
      </p>
    </li>
  </ul>
</section>

    `
}
        };

        components.forEach(component => {
    component.addEventListener('click', (event) => {
        event.stopPropagation(); // Evita que se dispare el evento del padre (como CPU)
        const type = component.getAttribute('data-component');
        const info = contentMap[type];

        if (info) {
            modalBody.innerHTML = `
                <h2>${info.title}</h2>
                ${info.content}
            `;
            modalOverlay.classList.add('active');
        }
    });
});
        function closeModal() {
            modalOverlay.classList.remove('active');
        }

        // Cierra al hacer clic fuera del modal
        modalOverlay.addEventListener('click', (e) => {
            if (e.target === modalOverlay) closeModal();
        });
    </script>

  <script>
    // Dibujar flechas din√°micas entre componentes
    window.addEventListener('load', () => {
      new LeaderLine(
        document.getElementById('cpu'),
        document.getElementById('memory'),
        { color: '#2c3e50', size: 3, endPlug: 'arrow' }
      );

      new LeaderLine(
        document.getElementById('memory'),
        document.getElementById('io'),
        { color: '#2c3e50', size: 3, endPlug: 'arrow' }
      );

      new LeaderLine(
        document.getElementById('cpu'),
        document.getElementById('bus'),
        { color: '#2c3e50', size: 3, endPlug: 'arrow' }
      );

      new LeaderLine(
        document.getElementById('memory'),
        document.getElementById('bus'),
        { color: '#2c3e50', size: 3, endPlug: 'arrow' }
      );

      new LeaderLine(
        document.getElementById('io'),
        document.getElementById('bus'),
        { color: '#2c3e50', size: 3, endPlug: 'arrow' }
      );
    });
  </script>
</body>
</html>
